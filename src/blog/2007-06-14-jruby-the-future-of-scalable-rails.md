{%
laika.title = "JRuby: The Future of Scalable Rails?"
laika.metadata.date = "2007-06-14"
%}


# JRuby: The Future of Scalable Rails?

So I was talking earlier today with my good friend, [Lowell Heddings](<http://www.lowellheddings.com>), regarding certain annoyances we had with web frameworks. The conversation started talking about the difficulties of developing PHP applications due to the lack of a debugger, but (as conversations on web frameworks are wont to do) eventually the migrated to Rails. I mentioned how I'd always been a bit distrustful of a web framework which ran on the one-request-per-persistent-process model. My reasons for distrusting this sort of framework were mainly related to performance and scalability, but Lowell brought up an interesting point that I hadn't considered before: process-shared sessions. See, because Rails runs as a parallel share-nothing process (i.e. the mongrel instances don't share memory state with one-another), trivial in-memory data can be a bit of a problem. Also, caching to disk can be a bit problematic since there are multiple processes attempting to access the on-disk data simultaneously. I'm sure many clever solutions have been mooted to solve this problem, but (I think) a new one occurred to me as we were discussing the problem. ( **caveat:** I haven't fleshed out this solution at all with any code. I'm posting it because Lowell thought it was an idea worth sharing) :-) My solution to the problem drops back into one of the hottest topic in Ruby today: JRuby on Rails. [JRuby ](<http://www.jruby.org>)allows you to run Rails applications in a Java-based and integrated environment, even to the extent of using existing Java tools, libraries and process containers. An ancillary project to JRuby even allows you to package up your Rails application within a WAR and host it directly within a Java application server like Tomcat or Glassfish. Packaging Rails as a WAR obviously necessitates a bit of configuration that wouldn't normally go into the deployment of a Rails application. For example, if you want to serve multiple requests with a Rails app concurrently, you would run multiple Mongrel instances and use an Apache mod_proxy configuration which would proxy requests to available server processes. Java web application, while they do run on the persistent-process model, are designed to be multi-threaded, rather than multi-process. Thus, Java web applications automatically scale to involve concurrent requests since all that is required is the spawning of a new thread within the application server. Rails however, is designed to be hosted as a separate process and would have to be extensively modified to support this kind of scaling directly. The solution found by the JRuby-extras project is to allow multiple Rails instances to be controlled by a single Rails app WAR. The number of instances is controlled by a configuration option within the _web.xml_ config file within the WAR. Thus, the JRuby WAR will spawn a new instance of the JRuby interpreter for each Rails process (as Rails expects), all hosted in separate threads within the same JVM instance, controlled by the Java app server. Thus, instead of going to all the hassle of configuring a new Mongrel instance and adding a mod_proxy rule to scale your Rails app, all that is necessary is to change a value in an XML file and to redeploy. This single-process encapsulation of Rails in this way allows us to provide a solution for Lowell's shared data problem. Instead of storing shared data (like application sessions or cached values) within the Rails process itself, the Rails application should use a Java class (hosted within the same WAR) to store the data. Thus, all shared application data should be stored at lower level than Rails, within the Java process itself. Java has some very solid concurrency APIs which would allow this sort of shared state without data corruption. ![JRuby-on-Rails Diagram](http://blogs.dzone.com/daniel/files/2007/06/jruby-rails-diagram.png) As the application scaled and the shared data requirements increased, the SharedCache class (as we'll christen it) could be modified to cluster, using Terracotta. The Rails WAR itself is already transparently clusterable through Java application servers like JBoss. As Lowell put it, it's like an infinitely scalable memcached, without all the fuss. Well, it's a thought anyway...